# 路径规划算法

问题定义：将目标从出发点移动到目的地。路径搜索是指搜索出一条好的路径——避开障碍物,并且使得总代价最低。运动的目标是找到一条路径并且沿着它行进，把关注的焦点仅集中于其中的一种方法是可能的。
## Dijkstra算法与最佳优先搜索
Dijkstra算法基于贪心思想，引用自[Blog](https://blog.csdn.net/qq_35644234/article/details/60875818)<br >
1. 先声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T<br >
2. 初始化：原点s的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。集合T只有顶点s<br >
3. 然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，此时完成一个顶点<br >
4. 然后，我们需要看看新加入的顶点是否可以到达其他顶点，并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值
5. 然后，重复步骤3和4，直到T中包含了图的所有顶点<br />["Case Test"](https://blog.csdn.net/qq_35644234/article/details/60875818) <br />

最佳优先搜索BFS<br />
- 不考虑障碍物，宽度搜索遍历图，直至找到目标

以上两张算法都没有考虑障碍物
## A*算法
依据某个或某些优化准则（如工作代价最小、行走路径最短、行走时间最短等），在工作空间中找到一个从起始状态到目标状态能避开障碍物的最优路径。
- 搜索区域：图中的搜索区域被划分为了简单的二维数组，数组每个元素对应一个小方格，当然我们也可以将区域等分成是五角星，矩形等，通常将一个单位的中心点称之为搜索区域节点
- 开放列表(Open List)：我们将路径规划过程中待检测的节点存放于Open List中，而已检测过的格子则存放于Close List中
- 父节点（parent）：在路径规划中用于回溯的节点，开发时可考虑为双向链表结构中的父结点指针
- 路径排序（Path Sorting）：具体往哪个节点移动由以下公式确定：F(n) = G + H 。G代表的是从初始位置A沿着已生成的路径到指定待检测格子的移动开销。H指定待测格子到目标节点B的估计移动开销
- 启发函数（Heuristics Function）：H为启发函数，也被认为是一种试探，由于在找到唯一路径前，我们不确定在前面会出现什么障碍物，因此用了一种计算H的算法，具体根据实际场景决定。在我们简化的模型中，H采用的是传统的曼哈顿距离（Manhattan Distance），也就是横纵向走的距离之和

算法总结<br >
- 把起点加入 open list
- 重复以下过程<br >
- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遍历open list ，查找F值最小的节点，把它作为当前要处理的节点，然后移到close list中<br >
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对当前方格的 8 个相邻方格一一进行检查，如果它是不可抵达的或者它在close list中，忽略它。否则，做如下操作:如果它不在open list中，把它加入open list，并且把当前方格设置为它的父亲;如果它已经在open list中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更近。如果更近，把它的父亲设置为当前方格，并重新计算它的G和F值。如果你的open list是按F值排序的话，改变后你可能需要重新排序
- 遇到下面情况停止搜索：把终点加入到了open list中，此时路径已经找到了，或者查找终点失败，并且open list 是空的，此时没有路径
